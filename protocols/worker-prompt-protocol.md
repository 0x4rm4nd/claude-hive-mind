# Worker Prompt File Protocol

## ðŸš¨ CRITICAL: Worker Prompt File Reading

**All workers MUST read their instructions from prompt files when spawned.**

### Implementation Pattern

```python
import os
from .session_management import SessionManagement

# Extract session ID from the prompt provided by Claude Code
# Session ID is passed in the prompt like: "Session ID: 2025-08-29-14-30-task-slug ..."
def extract_session_id_from_prompt(prompt):
    """Extract session ID from the worker prompt"""
    import re
    # Look for pattern: "Session ID: YYYY-MM-DD-HH-mm-taskslug"
    match = re.search(r'Session ID:\s*(\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-[\w-]+)', prompt)
    if match:
        return match.group(1)
    return None

# Get session ID
session_id = extract_session_id_from_prompt(prompt)

# Get session path
session_path = SessionManagement.get_session_path(session_id)

# Read worker-specific prompt file (replace WORKER_TYPE with actual type)
worker_type = "WORKER_TYPE"  # e.g., "analyzer-worker", "backend-worker", etc.
prompt_file = os.path.join(session_path, 'workers', 'prompts', f'{worker_type}.prompt')

with open(prompt_file, 'r') as f:
    task_instructions = f.read()

# Parse instructions to extract:
# - Primary task description
# - Specific focus areas
# - Dependencies
# - Timeout configuration
# - Success criteria
```

### Prompt File Contents

The prompt file generated by Queen contains:
- **Session ID**: For coordination and file management
- **Task Description**: Specific work assigned to this worker
- **Focus Areas**: Domain-specific priorities
- **Dependencies**: Other workers that must complete first
- **Timeout Settings**: Execution and escalation timeouts
- **Success Criteria**: Clear completion requirements
- **Output Requirements**: Where to save results
- **Coordination Notes**: Priority and session path

### Worker Startup Sequence

1. **Extract Session ID** from Claude Code prompt
2. **Read Prompt File** from `workers/prompts/{worker-type}.prompt`
3. **Validate Session** using `SessionManagement.ensure_session_exists(session_id)`
4. **Read State** using `SessionManagement.read_state(session_id)`
5. **Log Startup Event** to EVENTS.jsonl
6. **Check Dependencies** and prior work
7. **Execute Task** based on prompt file instructions
8. **Save Results** to specified output locations
9. **Update State** with completion status

### Output Requirements

Workers must generate:
- **JSON Response**: `workers/json/{worker-type}.json`
- **Detailed Analysis**: `workers/decisions/{worker-type}-analysis.md`
- **State Updates**: Update STATE.json with progress
- **Event Logs**: Log all significant events to EVENTS.jsonl

### Example Worker Implementation

```python
def worker_main(prompt):
    """Main worker execution function"""
    # 1. Extract session ID
    session_id = extract_session_id_from_prompt(prompt)
    if not session_id:
        raise ValueError("No session ID found in prompt")
    
    # 2. Read prompt file
    session_path = SessionManagement.get_session_path(session_id)
    prompt_file = os.path.join(session_path, 'workers', 'prompts', f'{WORKER_TYPE}.prompt')
    
    with open(prompt_file, 'r') as f:
        instructions = f.read()
    
    # 3. Log startup
    SessionManagement.append_to_events(session_id, {
        "timestamp": datetime.now().isoformat(),
        "type": "worker_started",
        "worker": WORKER_TYPE,
        "details": "Worker initialized and prompt file loaded"
    })
    
    # 4. Execute task based on instructions
    results = perform_analysis(instructions)
    
    # 5. Save results
    json_output = os.path.join(session_path, 'workers', 'json', f'{WORKER_TYPE}.json')
    with open(json_output, 'w') as f:
        json.dump(results, f, indent=2)
    
    # 6. Update state
    SessionManagement.update_state_atomically(session_id, {
        f"workers.{WORKER_TYPE}.status": "completed",
        f"workers.{WORKER_TYPE}.output": json_output
    })
    
    return results
```

## Integration with Workers

Each worker type should:
1. Import this protocol at the beginning of their agent file
2. Replace WORKER_TYPE with their actual type (e.g., "analyzer-worker")
3. Follow the startup sequence exactly
4. Read instructions from their prompt file, not from the initial prompt
5. Save outputs to the specified locations
6. Update session state upon completion